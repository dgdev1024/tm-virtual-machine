/**
 * @file  TM/CPU.c
 */

#include <TM/CPU.h>

// TM CPU Context Structure ////////////////////////////////////////////////////////////////////////

typedef struct TM_CPU
{

    // Function Pointers
    TM_BusRead  m_BusRead;  ///< @brief The function to read from the bus.
    TM_BusWrite m_BusWrite; ///< @brief The function to write to the bus.
    TM_Cycle    m_Cycle;    ///< @brief The function to call when a CPU cycle is completed.

    // General-Purpose Registers
    uint32_t m_A;           ///< @brief The accumulator register.
    uint32_t m_B;           ///< @brief The general-purpose register B, traditionally used as a base register.
    uint32_t m_C;           ///< @brief The general-purpose register C, traditionally used as a counter register.
    uint32_t m_D;           ///< @brief The general-purpose register D, traditionally used as a data register.

    // Program Counter and Stack Pointers
    uint32_t m_PC;          ///< @brief The program counter, which points to the next instruction to execute.
    uint16_t m_DSP;         ///< @brief The data stack pointer, which points to the top of the data stack.
    uint16_t m_CSP;         ///< @brief The call stack pointer, which points to the top of the call stack.

    // Internal Memory Registers
    uint32_t m_MD;          ///< @brief The memory data register, which holds data fetched from or to be written to memory.
    uint32_t m_MA;          ///< @brief The memory address register, which holds the address of the memory location to access.
    bool     m_DA;          ///< @brief The destination address flag, used to indicate whether the address in the memory address register is to be written to.

    // Internal Instruction Registers
    uint32_t m_IA;          ///< @brief The instruction address register, which holds the address of the current instruction's opcode.
    uint16_t m_CI;          ///< @brief The current instruction register, which holds the current instruction's opcode and parameters.
    uint8_t  m_OC;          ///< @brief The opcode register, which holds the current instruction's opcode.
    uint8_t  m_IP1;         ///< @brief The first instruction parameter register, which holds the first instruction's parameter.
    uint8_t  m_IP2;         ///< @brief The second instruction parameter register, which holds the second instruction's parameter.

    // Interrupt Registers
    uint16_t m_IE;         ///< @brief The interrupt enable register, which holds the mask for the enabled interrupts.
    uint16_t m_IF;         ///< @brief The interrupt flag register, which holds the mask for the pending interrupts.
    bool     m_IME;        ///< @brief The interrupt master enable flag, used to indicate whether interrupts are enabled or disabled.
    bool     m_EI;         ///< @brief The enable interrupts flag, used to indicate whether the CPU should enable interrupts on the next instruction.

    // Error Registers
    uint32_t m_EA;         ///< @brief The error address register, which holds the address of the last memory access which caused an error.
    uint8_t  m_EC;         ///< @brief The error code register, which holds the last error code generated by the CPU.

    // Halt and Stop Flags
    bool     m_Halt;       ///< @brief The halt flag, used to indicate whether the CPU is halted or not.
    bool     m_Stop;       ///< @brief The stop flag, used to indicate whether the CPU is stopped or not.

    // Flags Register
    union
    {
        uint8_t m_Register; ///< @brief The raw value of the flags register, which contains the status of the CPU's last operation.
        struct
        {
            uint8_t     : 4;    ///< @brief Unused bits, reserved for future use.
            uint8_t m_C : 1;    ///< @brief The carry flag, used to indicate if a carry occurred in the last operation's result.
            uint8_t m_H : 1;    ///< @brief The half-carry flag, used to indicate if a carry occurred in a portion of the last operation's result.
            uint8_t m_N : 1;    ///< @brief The subtract flag, used to indicate if the last operation was (or involved) a subtraction.
            uint8_t m_Z : 1;    ///< @brief The zero flag, used to indicate if the result of the last operation was zero.
        };
    } m_Flags;

} TM_CPU;

// Private Function Prototypes /////////////////////////////////////////////////////////////////////

static void TM_AdvanceCPU (TM_CPU* p_CPU, uint32_t p_Cycles);
static bool TM_IsReadable (const TM_CPU* p_CPU, uint32_t p_Address, size_t p_Size);
static bool TM_IsWritable (const TM_CPU* p_CPU, uint32_t p_Address, size_t p_Size);
static bool TM_IsExecutable (const TM_CPU* p_CPU, uint32_t p_Address);
static uint32_t TM_PopData (TM_CPU* p_CPU);
static uint32_t TM_PopAddress (TM_CPU* p_CPU);
static void TM_PushData (TM_CPU* p_CPU, uint32_t p_Value);
static void TM_PushAddress (TM_CPU* p_CPU, uint32_t p_Address);
static void TM_ServiceInterrupt (TM_CPU* p_CPU);

// Private Functions - Miscellaneous ///////////////////////////////////////////////////////////////

void TM_AdvanceCPU (TM_CPU* p_CPU, uint32_t p_Cycles)
{
    assert(p_CPU != NULL);

    // Cycle the CPU for the specified number of cycles.
    TM_CycleCPU(p_CPU, p_Cycles);

    // Advance the program counter by the same number of cycles.
    p_CPU->m_PC += p_Cycles;
}

// Private Functions - Memory Bounds Checking //////////////////////////////////////////////////////

bool TM_IsReadable (const TM_CPU* p_CPU, uint32_t p_Address, size_t p_Size)
{
    assert(p_CPU != NULL);

    // The readable bounds of the TM CPU's memory map are listed as follows:
    // - `0x00000000` to `0x00000FFF` - Program Metadata
    // - `0x40000000` to `0x7FFFFFFF` - Program Data
    // - `0x80000000` to `0xFFFCFFFF` - DRAM and XRAM
    // - `0xFFFF0000` to `0xFFFFFFFF` - QRAM and I/O Ports
    return (
        (p_Address >= TM_MDATA_BEGIN && p_Address + p_Size <= TM_MDATA_END) ||
        (p_Address >= TM_DATA_BEGIN  && p_Address + p_Size <= TM_DATA_END ) ||
        (p_Address >= TM_DRAM_BEGIN  && p_Address + p_Size <= TM_XRAM_END ) ||
        (p_Address >= TM_QRAM_BEGIN)
    );
}

bool TM_IsWritable (const TM_CPU* p_CPU, uint32_t p_Address, size_t p_Size)
{
    assert(p_CPU != NULL);

    // The writable bounds of the TM CPU's memory map are listed as follows:
    // - `0x40000000` to `0x7FFFFFFF` - DRAM and XRAM
    // - `0x80000000` to `0xFFFCFFFF` - QRAM and I/O Ports
    return (
        (p_Address >= TM_DRAM_BEGIN && p_Address + p_Size <= TM_XRAM_END) ||
        (p_Address >= TM_QRAM_BEGIN)
    );
}

bool TM_IsExecutable (const TM_CPU* p_CPU, uint32_t p_Address)
{
    assert(p_CPU != NULL);

    // The executable bounds of the TM CPU's memory map are listed as follows:
    // - `0x00001000` to `0x00002FFF` - Restart Vectors and Interrupt Handlers
    // - `0x00003000` to `0x3FFFFFFF` - Program Code
    // - `0xE0000000` to `0xFFFCFFFF` - XRAM
    //
    return (
        (p_Address >= TM_RST_BEGIN  && p_Address + 2 <= TM_INT_END ) ||
        (p_Address >= TM_CODE_BEGIN && p_Address + 2 <= TM_CODE_END) ||
        (p_Address >= TM_XRAM_BEGIN && p_Address + 2 <= TM_XRAM_END)
    );
}

// Private Functions - Stack Operations ////////////////////////////////////////////////////////////

uint32_t TM_PopData (TM_CPU* p_CPU)
{
    assert(p_CPU != NULL);
    
    // Ensure the data stack is not empty.
    if (p_CPU->m_DSP >= 0xFFFC)
    {
        TM_SetErrorCode(p_CPU, TM_EC_DATA_STACK_UNDERFLOW);
        return 0;
    }

    // Read the value from the data stack pointer, then increment the data stack pointer.
    uint32_t l_Value = TM_ReadDoubleWord(p_CPU, TM_DSTACK_BEGIN + p_CPU->m_DSP);
    p_CPU->m_DSP += 4;

    // Popping from a stack takes five cycles:
    // - Four cycles to read the bytes from the stack.
    // - One cycle to move the stack pointer after the read.
    TM_CycleCPU(p_CPU, 5);

    return l_Value;
}

uint32_t TM_PopAddress (TM_CPU* p_CPU)
{
    assert(p_CPU != NULL);
    
    // Ensure the call stack is not empty.
    //
    // The call stack is popped from only by the `RET` and `RETI` instructions. If the call stack
    // is empty, then the CPU will interpret this as a normal program exit, and will set the error code
    // to `TM_EC_OK` to indicate that the program has exited successfully. This is analogous to
    // executing a `SEC 00` instruction, followed by a `STOP` instruction.
    if (p_CPU->m_CSP >= 0xFFFC)
    {
        TM_SetErrorCode(p_CPU, TM_EC_OK);
        return 0;
    }

    // Read the value from the call stack pointer, then increment the call stack pointer.
    uint32_t l_Value = TM_ReadDoubleWord(p_CPU, TM_CSTACK_BEGIN + p_CPU->m_CSP);
    p_CPU->m_CSP += 4;

    // Popping from a stack takes five cycles:
    // - Four cycles to read the bytes from the stack.
    // - One cycle to move the stack pointer after the read.
    TM_CycleCPU(p_CPU, 5);

    return l_Value;
}

void TM_PushData (TM_CPU* p_CPU, uint32_t p_Value)
{
    assert(p_CPU != NULL);
    
    // Ensure the data stack is not full.
    if (p_CPU->m_DSP <= 3)
    {
        TM_SetErrorCode(p_CPU, TM_EC_DATA_STACK_OVERFLOW);
        return;
    }

    // Decrement the data stack pointer, then write the value to the data stack.
    p_CPU->m_DSP -= 4;
    TM_WriteDoubleWord(p_CPU, TM_DSTACK_BEGIN + p_CPU->m_DSP, p_Value);

    // Pushing to a stack takes five cycles:
    // - Four cycles to write the bytes to the stack.
    // - One cycle to move the stack pointer after the write.
    TM_CycleCPU(p_CPU, 5);
}

void TM_PushAddress (TM_CPU* p_CPU, uint32_t p_Address)
{
    assert(p_CPU != NULL);
    
    // Ensure the call stack is not full.
    if (p_CPU->m_CSP <= 3)
    {
        TM_SetErrorCode(p_CPU, TM_EC_CALL_STACK_OVERFLOW);
        return;
    }

    // Decrement the call stack pointer, then write the address to the call stack.
    p_CPU->m_CSP -= 4;
    TM_WriteDoubleWord(p_CPU, TM_CSTACK_BEGIN + p_CPU->m_CSP, p_Address);

    // Pushing to a stack takes five cycles:
    // - Four cycles to write the bytes to the stack.
    // - One cycle to move the stack pointer after the write.
    TM_CycleCPU(p_CPU, 5);
}

// Private Functions - Interrupts //////////////////////////////////////////////////////////////////

void TM_ServiceInterrupt (TM_CPU* p_CPU)
{
    assert(p_CPU != NULL);

    // Iterate over the 16 bits of the interrupt flags register.
    for (uint8_t i = 0; i < 16; ++i)
    {
        // Check if the interrupt is pending and enabled.
        if ((p_CPU->m_IF & (1 << i)) && (p_CPU->m_IE & (1 << i)))
        {
            // Acknowledge the interrupt:
            // - Clear the bit in the interrupt flag register.
            // - Clear the interrupt master enable flag.
            // - Clear the halt flag.
            p_CPU->m_IF &= ~(1 << i);
            p_CPU->m_IME = false;
            p_CPU->m_Halt = false;

            // Call the interrupt handler:
            // - Push the program counter onto the call stack.
            // - Set the program counter to the interrupt vector address.
            TM_PushAddress(p_CPU, p_CPU->m_PC);
            p_CPU->m_PC = TM_INT_BEGIN + (0x100 * i);
        }
    }
}

// Public Functions ////////////////////////////////////////////////////////////////////////////////

TM_CPU* TM_CreateCPU (TM_BusRead p_BusRead, TM_BusWrite p_BusWrite, TM_Cycle p_Cycle)
{
    // Ensure the given function pointers are valid.
    if (p_BusRead == NULL || p_BusWrite == NULL || p_Cycle == NULL)
    {
        fprintf(stderr, "TM: Cannot create CPU instance - missing or invalid function pointers.\n");
        return NULL;
    }

    // Allocate memory for the CPU instance.
    TM_CPU* l_CPU = (TM_CPU*) calloc(1, sizeof(TM_CPU));
    if (l_CPU == NULL)
    {
        perror("TM: Failed to allocate memory for the CPU instance");
        return NULL;
    }

    // Initialize the CPU instance and set the function pointers.
    TM_ResetCPU(l_CPU);
    l_CPU->m_BusRead = p_BusRead;
    l_CPU->m_BusWrite = p_BusWrite;
    l_CPU->m_Cycle = p_Cycle;

    return l_CPU;
}

void TM_ResetCPU (TM_CPU* p_CPU)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot reset CPU instance - invalid CPU instance.\n");
        return;
    }
    
    // Reset the general-purpose registers.
    p_CPU->m_A = 0;
    p_CPU->m_B = 0;
    p_CPU->m_C = 0;
    p_CPU->m_D = 0;

    // Reset the program counter and stack pointers.
    p_CPU->m_PC = TM_CODE_BEGIN;
    p_CPU->m_DSP = 0xFFFC;
    p_CPU->m_CSP = 0xFFFC;

    // Reset the internal memory registers.
    p_CPU->m_MD = 0;
    p_CPU->m_MA = 0;
    p_CPU->m_DA = false;

    // Reset the internal instruction registers.
    p_CPU->m_IA = 0;
    p_CPU->m_CI = 0;
    p_CPU->m_OC = 0;
    p_CPU->m_IP1 = 0;
    p_CPU->m_IP2 = 0;

    // Reset the interrupt registers.
    p_CPU->m_IE = 0;
    p_CPU->m_IF = 0;
    p_CPU->m_IME = false;
    p_CPU->m_EI = false;

    // Reset the error registers.
    p_CPU->m_EA = 0;
    p_CPU->m_EC = TM_EC_OK;

    // Reset the halt and stop flags.
    p_CPU->m_Halt = false;
    p_CPU->m_Stop = false;

    // Reset the flags register.
    p_CPU->m_Flags.m_Register = 0;
}

void TM_DestroyCPU (TM_CPU* p_CPU)
{
    // Do nothing if the CPU instance is NULL.
    if (p_CPU == NULL)
    {
        return;
    }

    // Free the memory allocated for the CPU instance.
    free(p_CPU);
    p_CPU = NULL;
}

void TM_CycleCPU (TM_CPU* p_CPU, uint32_t p_Cycles)
{
    // Ensure the given CPU instance, and its cycle function pointer, are valid.
    if (p_CPU == NULL || p_CPU->m_Cycle == NULL)
    {
        fprintf(stderr, "TM: Cannot cycle CPU instance - invalid CPU instance or cycle function pointer.\n");
        return;
    }

    // Cycle the CPU for the specified number of cycles.
    for (uint32_t i = 0; i < p_Cycles; ++i)
    {
        if (p_CPU->m_Cycle(p_Cycles) == false)
        {
            TM_SetErrorCode(p_CPU, TM_EC_HARDWARE_FAULT);
            return;
        }
    }
}

void TM_StepCPU (TM_CPU* p_CPU)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot step CPU instance - invalid CPU instance.\n");
        return;
    }

    // If the CPU is stopped, do nothing.
    if (p_CPU->m_Stop)
    {
        return;
    }

    // If the CPU is halted, wait for an interrupt to be requested.
    // Otherwise, process the next instruction.
    if (p_CPU->m_Halt == true)
    {
        // Cycle the CPU, then un-halt the CPU if an interrupt is requested.
        TM_CycleCPU(p_CPU, 1);
        p_CPU->m_Halt = (p_CPU->m_IF == 0);
    }
    else
    {
        // Reset the memory registers.
        p_CPU->m_MD = 0;
        p_CPU->m_MA = 0;
        p_CPU->m_DA = false;

        // Copy the program counter to the instruction address register. Make sure the address is
        // within the executable bounds of the CPU's memory map.
        p_CPU->m_IA = p_CPU->m_PC;
        if (TM_IsExecutable(p_CPU, p_CPU->m_IA) == false)
        {
            TM_SetErrorCode(p_CPU, TM_EC_BAD_EXECUTE);
            p_CPU->m_EA = p_CPU->m_IA;
            return;
        }

        // Read the instruction's 16-bit opcode from the bus at the instruction address.
        p_CPU->m_CI = TM_ReadWord(p_CPU, p_CPU->m_IA);
        TM_AdvanceCPU(p_CPU, 2);

        // Decode the instruction's 8-bit opcode and parameters.
        p_CPU->m_OC = (p_CPU->m_CI >> 8) & 0xFF;
        p_CPU->m_IP1 = (p_CPU->m_CI >> 4) & 0x0F;
        p_CPU->m_IP2 = (p_CPU->m_CI >> 0) & 0x0F;

        // Depending upon the opcode and parameters, fetch the necessary data from the bus, then
        // execute the instruction.
        bool l_Good = false;
        switch (p_CPU->m_OC)
        {
            default:
                TM_SetErrorCode(p_CPU, TM_EC_INVALID_OPCODE);
                p_CPU->m_EA = p_CPU->m_IA;
                return;
        }

        if (l_Good == false)
        {
            return;
        }
    }

    // If the interrupt master enable flag is set, service a pending interrupt, if there is one.
    if (p_CPU->m_IME == true)
    {
        TM_ServiceInterrupt(p_CPU);
    }

    // If the interrupt master enable flag is to be set, then set it here.
    if (p_CPU->m_EI == true)
    {
        p_CPU->m_IME = true;
        p_CPU->m_EI = false;
    }
}

uint8_t TM_ReadByte (TM_CPU* p_CPU, uint32_t p_Address)
{
    // Ensure the given CPU instance, and its bus read function pointer, are valid.
    if (p_CPU == NULL || p_CPU->m_BusRead == NULL)
    {
        fprintf(stderr, "TM: Cannot read byte from CPU instance - invalid CPU instance or bus read function pointer.\n");
        return 0xFF;
    }

    // Read a byte from the bus at the specified address.
    uint8_t l_Byte0 = p_CPU->m_BusRead(p_Address);
    return l_Byte0;
}

uint16_t TM_ReadWord (TM_CPU* p_CPU, uint32_t p_Address)
{
    // Ensure the given CPU instance, and its bus read function pointer, are valid.
    if (p_CPU == NULL || p_CPU->m_BusRead == NULL)
    {
        fprintf(stderr, "TM: Cannot read word from CPU instance - invalid CPU instance or bus read function pointer.\n");
        return 0xFFFF;
    }

    // Read the two bytes making up the word from the bus at the specified address. Combine them,
    // and return the result.
    uint16_t l_Word0 = p_CPU->m_BusRead(p_Address);
    uint16_t l_Word1 = p_CPU->m_BusRead(p_Address + 1);
    return (l_Word0 | (l_Word1 << 8));
}

uint32_t TM_ReadDoubleWord (TM_CPU* p_CPU, uint32_t p_Address)
{
    // Ensure the given CPU instance, and its bus read function pointer, are valid.
    if (p_CPU == NULL || p_CPU->m_BusRead == NULL)
    {
        fprintf(stderr, "TM: Cannot read double word from CPU instance - invalid CPU instance or bus read function pointer.\n");
        return 0xFFFFFFFF;
    }

    // Read the four bytes making up the double word from the bus at the specified address. Combine
    // them, and return the result.
    uint32_t l_DWord0 = p_CPU->m_BusRead(p_Address);
    uint32_t l_DWord1 = p_CPU->m_BusRead(p_Address + 1);
    uint32_t l_DWord2 = p_CPU->m_BusRead(p_Address + 2);
    uint32_t l_DWord3 = p_CPU->m_BusRead(p_Address + 3);
    return (l_DWord0 | (l_DWord1 << 8) | (l_DWord2 << 16) | (l_DWord3 << 24));
}

void TM_WriteByte (TM_CPU* p_CPU, uint32_t p_Address, uint8_t p_Data)
{
    // Ensure the given CPU instance, and its bus write function pointer, are valid.
    if (p_CPU == NULL || p_CPU->m_BusWrite == NULL)
    {
        fprintf(stderr, "TM: Cannot write byte to CPU instance - invalid CPU instance or bus write function pointer.\n");
        return;
    }

    // Write a byte to the bus at the specified address.
    p_CPU->m_BusWrite(p_Address, p_Data);
}

void TM_WriteWord (TM_CPU* p_CPU, uint32_t p_Address, uint16_t p_Data)
{
    // Ensure the given CPU instance, and its bus write function pointer, are valid.
    if (p_CPU == NULL || p_CPU->m_BusWrite == NULL)
    {
        fprintf(stderr, "TM: Cannot write word to CPU instance - invalid CPU instance or bus write function pointer.\n");
        return;
    }

    // Write the two bytes making up the word to the bus at the specified address.
    p_CPU->m_BusWrite(p_Address, p_Data & 0xFF);
    p_CPU->m_BusWrite(p_Address + 1, (p_Data >> 8) & 0xFF);
}

void TM_WriteDoubleWord (TM_CPU* p_CPU, uint32_t p_Address, uint32_t p_Data)
{
    // Ensure the given CPU instance, and its bus write function pointer, are valid.
    if (p_CPU == NULL || p_CPU->m_BusWrite == NULL)
    {
        fprintf(stderr, "TM: Cannot write double word to CPU instance - invalid CPU instance or bus write function pointer.\n");
        return;
    }

    // Write the four bytes making up the double word to the bus at the specified address.
    p_CPU->m_BusWrite(p_Address, p_Data & 0xFF);
    p_CPU->m_BusWrite(p_Address + 1, (p_Data >> 8) & 0xFF);
    p_CPU->m_BusWrite(p_Address + 2, (p_Data >> 16) & 0xFF);
    p_CPU->m_BusWrite(p_Address + 3, (p_Data >> 24) & 0xFF);
}

void TM_RequestInterrupt (TM_CPU* p_CPU, uint8_t p_Interrupt)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot request interrupt - invalid CPU instance.\n");
        return;
    }

    // Set the interrupt flag for the specified interrupt.
    p_CPU->m_IF |= (1 << p_Interrupt);
}

uint32_t TM_GetRegister (const TM_CPU* p_CPU, TM_CPURegister p_Register)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot get register - invalid CPU instance.\n");
        return 0;
    }

    // Return the value of the specified register.
    switch (p_Register)
    {
        case TM_REG_A:  return p_CPU->m_A;
        case TM_REG_AW: return p_CPU->m_A & 0xFFFF;
        case TM_REG_AH: return (p_CPU->m_A >> 8) & 0xFF;
        case TM_REG_AL: return p_CPU->m_A & 0xFF;
        case TM_REG_B:  return p_CPU->m_B;
        case TM_REG_BW: return p_CPU->m_B & 0xFFFF;
        case TM_REG_BH: return (p_CPU->m_B >> 8) & 0xFF;
        case TM_REG_BL: return p_CPU->m_B & 0xFF;
        case TM_REG_C:  return p_CPU->m_C;
        case TM_REG_CW: return p_CPU->m_C & 0xFFFF;
        case TM_REG_CH: return (p_CPU->m_C >> 8) & 0xFF;
        case TM_REG_CL: return p_CPU->m_C & 0xFF;
        case TM_REG_D:  return p_CPU->m_D;
        case TM_REG_DW: return p_CPU->m_D & 0xFFFF;
        case TM_REG_DH: return (p_CPU->m_D >> 8) & 0xFF;
        case TM_REG_DL: return p_CPU->m_D & 0xFF;
        default:
            fprintf(stderr, "TM: Invalid register specified.\n");
            return 0;
    }
}

void TM_SetRegister (TM_CPU* p_CPU, TM_CPURegister p_Register, uint32_t p_Value)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot set register - invalid CPU instance.\n");
        return;
    }

    // Set the value of the specified register.
    switch (p_Register)
    {
        case TM_REG_A:  p_CPU->m_A = p_Value; break;
        case TM_REG_AW: p_CPU->m_A = (p_CPU->m_A & 0xFFFF0000) | (p_Value & 0xFFFF); break;
        case TM_REG_AH: p_CPU->m_A = (p_CPU->m_A & 0xFFFF00FF) | ((p_Value & 0xFF) << 8); break;
        case TM_REG_AL: p_CPU->m_A = (p_CPU->m_A & 0xFFFFFF00) | (p_Value & 0xFF); break;
        case TM_REG_B:  p_CPU->m_B = p_Value; break;
        case TM_REG_BW: p_CPU->m_B = (p_CPU->m_B & 0xFFFF0000) | (p_Value & 0xFFFF); break;
        case TM_REG_BH: p_CPU->m_B = (p_CPU->m_B & 0xFFFF00FF) | ((p_Value & 0xFF) << 8); break;
        case TM_REG_BL: p_CPU->m_B = (p_CPU->m_B & 0xFFFFFF00) | (p_Value & 0xFF); break;
        case TM_REG_C:  p_CPU->m_C = p_Value; break;
        case TM_REG_CW: p_CPU->m_C = (p_CPU->m_C & 0xFFFF0000) | (p_Value & 0xFFFF); break;
        case TM_REG_CH: p_CPU->m_C = (p_CPU->m_C & 0xFFFF00FF) | ((p_Value & 0xFF) << 8); break;
        case TM_REG_CL: p_CPU->m_C = (p_CPU->m_C & 0xFFFFFF00) | (p_Value & 0xFF); break;
        case TM_REG_D:  p_CPU->m_D = p_Value; break;
        case TM_REG_DW: p_CPU->m_D = (p_CPU->m_D & 0xFFFF0000) | (p_Value & 0xFFFF); break;
        case TM_REG_DH: p_CPU->m_D = (p_CPU->m_D & 0xFFFF00FF) | ((p_Value & 0xFF) << 8); break;
        case TM_REG_DL: p_CPU->m_D = (p_CPU->m_D & 0xFFFFFF00) | (p_Value & 0xFF); break;
        default:
            fprintf(stderr, "TM: Invalid register specified.\n");
            break;
    }
}

bool TM_GetFlag (const TM_CPU* p_CPU, TM_CPUFlag p_Flag)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot get flag - invalid CPU instance.\n");
        return false;
    }

    // Return the value of the specified flag.
    switch (p_Flag)
    {
        case TM_FLAG_Z: return p_CPU->m_Flags.m_Z;
        case TM_FLAG_N: return p_CPU->m_Flags.m_N;
        case TM_FLAG_H: return p_CPU->m_Flags.m_H;
        case TM_FLAG_C: return p_CPU->m_Flags.m_C;
        default:
            fprintf(stderr, "TM: Invalid flag specified.\n");
            return false;
    }
}

void TM_SetFlag (TM_CPU* p_CPU, TM_CPUFlag p_Flag, bool p_Value)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot set flag - invalid CPU instance.\n");
        return;
    }

    // Set the value of the specified flag.
    switch (p_Flag)
    {
        case TM_FLAG_Z: p_CPU->m_Flags.m_Z = p_Value; break;
        case TM_FLAG_N: p_CPU->m_Flags.m_N = p_Value; break;
        case TM_FLAG_H: p_CPU->m_Flags.m_H = p_Value; break;
        case TM_FLAG_C: p_CPU->m_Flags.m_C = p_Value; break;
        default:
            fprintf(stderr, "TM: Invalid flag specified.\n");
            break;
    }
}

void TM_SetFlags (TM_CPU* p_CPU, int8_t p_Z, int8_t p_N, int8_t p_H, int8_t p_C)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot set flags - invalid CPU instance.\n");
        return;
    }

    // Set the values of the specified flags. If negative values are passed, the flags are left unchanged.
    if (p_Z >= 0) { p_CPU->m_Flags.m_Z = (p_Z > 0); }
    if (p_N >= 0) { p_CPU->m_Flags.m_N = (p_N > 0); }
    if (p_H >= 0) { p_CPU->m_Flags.m_H = (p_H > 0); }
    if (p_C >= 0) { p_CPU->m_Flags.m_C = (p_C > 0); }
}

uint8_t TM_GetInterruptEnable (const TM_CPU* p_CPU)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot get interrupt enable - invalid CPU instance.\n");
        return 0;
    }

    // Return the value of the interrupt enable register.
    return p_CPU->m_IE;
}

uint8_t TM_GetInterruptFlags (const TM_CPU* p_CPU)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot get interrupt flags - invalid CPU instance.\n");
        return 0;
    }

    // Return the value of the interrupt flag register.
    return p_CPU->m_IF;
}

void TM_SetInterruptEnable (TM_CPU* p_CPU, uint8_t p_Value)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot set interrupt enable - invalid CPU instance.\n");
        return;
    }

    // Set the value of the interrupt enable register.
    p_CPU->m_IE = p_Value;
}

void TM_SetInterruptFlags (TM_CPU* p_CPU, uint8_t p_Value)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot set interrupt flags - invalid CPU instance.\n");
        return;
    }

    // Set the value of the interrupt flag register.
    p_CPU->m_IF = p_Value;
}

bool TM_GetInterruptMasterEnable (const TM_CPU* p_CPU)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot get interrupt master enable - invalid CPU instance.\n");
        return false;
    }

    // Return the value of the interrupt master enable flag.
    return p_CPU->m_IME;
}

uint32_t TM_GetProgramCounter (const TM_CPU* p_CPU)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot get program counter - invalid CPU instance.\n");
        return 0;
    }

    // Return the value of the program counter.
    return p_CPU->m_PC;
}

void TM_SetProgramCounter (TM_CPU* p_CPU, uint32_t p_Value)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot set program counter - invalid CPU instance.\n");
        return;
    }

    // Set the value of the program counter.
    p_CPU->m_PC = p_Value;
}

uint32_t TM_GetDataStackPointer (const TM_CPU* p_CPU)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot get data stack pointer - invalid CPU instance.\n");
        return 0;
    }

    // Return the value of the data stack pointer.
    return p_CPU->m_DSP;
}

uint32_t TM_GetCallStackPointer (const TM_CPU* p_CPU)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot get call stack pointer - invalid CPU instance.\n");
        return 0;
    }

    // Return the value of the call stack pointer.
    return p_CPU->m_CSP;
}

uint8_t TM_GetErrorCode (const TM_CPU* p_CPU)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot get error code - invalid CPU instance.\n");
        return 0;
    }

    // Return the value of the error code register.
    return p_CPU->m_EC;
}

bool TM_SetErrorCode (TM_CPU* p_CPU, uint8_t p_ErrorCode)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot set error code - invalid CPU instance.\n");
        return false;
    }

    // Set the value of the error code register.
    p_CPU->m_EC = p_ErrorCode;
    return (p_ErrorCode == TM_EC_OK);
}

bool TM_IsHalted (const TM_CPU* p_CPU)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot get halt flag - invalid CPU instance.\n");
        return false;
    }

    // Return the value of the halt flag.
    return p_CPU->m_Halt;
}

bool TM_IsStopped (const TM_CPU* p_CPU)
{
    // Ensure the given CPU instance is valid.
    if (p_CPU == NULL)
    {
        fprintf(stderr, "TM: Cannot get stop flag - invalid CPU instance.\n");
        return false;
    }

    // Return the value of the stop flag.
    return p_CPU->m_Stop;
}
